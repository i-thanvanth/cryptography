def gcd(a,b):
    #Euclidean Algorithm
    while b!=0:
        a,b= b,a%b
    return a
import sympy
import random

#The math part:
#Generating pseudorandom prime numbers that aren't equal
def prime():
    p_1, p_2 = sympy.randprime(random.getrandbits(5),random.getrandbits(10)), sympy.randprime(random.getrandbits(5),random.getrandbits(10))
    if p_1 == p_2:
        prime()
    return p_1,p_2

p_1,p_2=prime()    

print("----------------------------","\n The two random prime numbers used are: ",p_1,p_2) 
n = p_1*p_2
phi = (p_1-1)*(p_2-1)

#finding an e that is a coprime of phi as well as n 
e = sympy.randprime(1, phi)
g = gcd(e, phi)
h = gcd(e, n)
while g != 1 and h !=1 :
    e = sympy.randprime(1, phi)
    g = gcd(e, phi)
    h = gcd(e,n)
print(" The encryptor is: ",e,"\n The mod is: ",n,"\n The phi(n) is:",phi)
#Using the sympy module to find the modulo inverse of e, Euclidean's extended algorithm could also be used for the same
d = sympy.mod_inverse(e,phi)
print(" The private key, generated by finding the modulo inverse of e: ",d,"\n----------------------------")

#Encryption part:
def encrypt(public_key, text):
    e,n = public_key
    encrypted_text=[]
    for i in text:
        c = (ord(i)**e)%n
        encrypted_text.append(c)
    return encrypted_text

text = input(" Enter text to be encrypted: ")
print("----------------------------","\n Encrypting the entered text with the public key, e........")
print("The cipher text is: ",encrypt((e,n), text))
print("----------------------------")

#Decryption part:
def decryptor(private_key, encrypted_text):
    d,n = private_key
    decrypted_text=''
    for i in encrypted_text:
        d_t = (int(i)**d)%n
        decrypted_text+=chr(d_t)
    return decrypted_text
print(" NOW ONTO DECRYPTION....")
decrypt= input(" Enter the numbers separated by commas: ").split(',')
print("\nDecrypting the key with the decryptor, d........","\n The decrypted text is:",decryptor((d,n),decrypt),"\n----------------------------")